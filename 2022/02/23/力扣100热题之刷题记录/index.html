<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>LeetCode HOT 100 之总结记录 | xinxin's little world</title><meta name="keywords" content="LeetCode"><meta name="author" content="xinxin"><meta name="copyright" content="xinxin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="持续记录中..."><meta property="og:type" content="article"><meta property="og:title" content="LeetCode HOT 100 之总结记录"><meta property="og:url" content="http://xinxin-l.github.io/2022/02/23/%E5%8A%9B%E6%89%A3100%E7%83%AD%E9%A2%98%E4%B9%8B%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/index.html"><meta property="og:site_name" content="xinxin&#39;s little world"><meta property="og:description" content="持续记录中..."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://npm.elemecdn.com/xinxin-l-assets/img/v2-11fed20c0b85026cff9036f599ca3d2f_b.jpg"><meta property="article:published_time" content="2022-02-23T14:01:32.000Z"><meta property="article:modified_time" content="2022-04-06T08:19:34.746Z"><meta property="article:author" content="xinxin"><meta property="article:tag" content="LeetCode"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://npm.elemecdn.com/xinxin-l-assets/img/v2-11fed20c0b85026cff9036f599ca3d2f_b.jpg"><link rel="shortcut icon" href="/img/fa.jpg"><link rel="canonical" href="http://xinxin-l.github.io/2022/02/23/%E5%8A%9B%E6%89%A3100%E7%83%AD%E9%A2%98%E4%B9%8B%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"LeetCode HOT 100 之总结记录",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-06 16:19:34"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/loading_wizard.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="//at.alicdn.com/t/font_3175482_nvqwetat8za.css"><link rel="stylesheet" href="/css/cursor.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>Music</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-cubes"></i> <span>Talk</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i> <span>Comments</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://npm.elemecdn.com/xinxin-l-assets/img/v2-11fed20c0b85026cff9036f599ca3d2f_b.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">xinxin's little world</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>Music</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-cubes"></i> <span>Talk</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i> <span>Comments</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeetCode HOT 100 之总结记录<a class="post-edit-link" href="null_posts/力扣100热题之刷题记录.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-23T14:01:32.000Z" title="发表于 2022-02-23 22:01:32">2022-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-06T08:19:34.746Z" title="更新于 2022-04-06 16:19:34">2022-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>69分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="LeetCode HOT 100 之总结记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/02/23/%E5%8A%9B%E6%89%A3100%E7%83%AD%E9%A2%98%E4%B9%8B%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/02/23/%E5%8A%9B%E6%89%A3100%E7%83%AD%E9%A2%98%E4%B9%8B%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><div class="note default modern"><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul></div><p>这道题不难，使用栈的思想就好了，要多考虑特殊情况，比如只有一个字符，或者输入的是”((((“，还需最后判断栈是否为空</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left=[<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>]</span><br><span class="line">    <span class="keyword">let</span> right=[<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>]</span><br><span class="line">    <span class="keyword">let</span> arr=[]</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;s.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.indexOf(s[i])&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            arr.push(s[i])</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> t=arr.pop()</span><br><span class="line">            <span class="keyword">let</span> index1=left.indexOf(t)</span><br><span class="line">            <span class="keyword">let</span> index2=right.indexOf(s[i])</span><br><span class="line">            <span class="keyword">if</span>(index1!==index2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h2><div class="note default modern"><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>实现 MinStack 类:<br>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。</p></div><p><strong>好几次都做不对</strong>的一个点：在初始化函数中，要<code>this.arr=[]</code>，不要<code>var arr=[]</code></p><p>要记住，栈顶是哪里</p><p>栈顶不是arr[0]，是arr最末尾</p><p><br></p><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a></p><div class="note default modern"><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p></div><p>这道题是<strong>单调栈的应用</strong>，遇到温度t就准备入栈，在栈中只存当前递减的温度值，如果该温度t比当前栈尾温度值大，就不停pop，同时记录这俩温度之间所差天数，直到在栈中遇到比t更大的温度或者栈空，就把温度t <strong>push</strong>进去</p><p>需要注意的是，在栈中保存的是<strong>当前的天数值</strong>（也就是索引、下标）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dailyTemperatures = <span class="function"><span class="keyword">function</span>(<span class="params">temperatures</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len=temperatures.length</span><br><span class="line">  <span class="keyword">let</span> res=<span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> i=<span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> arr=[]</span><br><span class="line">  <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!arr.length)&#123;</span><br><span class="line">      arr.push(i)</span><br><span class="line">      i++</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> num=arr[arr.length-<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">while</span>(arr.length &amp;&amp; temperatures[i]&gt;temperatures[num])&#123;</span><br><span class="line">        res[num]=i-num</span><br><span class="line">        arr.pop()</span><br><span class="line">        num=arr[arr.length-<span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      arr.push(i)</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="5-最长回文串"><a href="#5-最长回文串" class="headerlink" title="5. 最长回文串"></a>5. 最长回文串</h2><div class="note default modern"><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p></div><p>使用<strong>中心扩散法</strong>，使每个字符都充当回文串的中心</p><p>此时就需要分情况讨论，中心为1个数还是2个，即回文串为奇数还是偶数；若当前访问字符满足回文串条件（在s中且相同），则继续向外扩散，直到不满足条件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        getString(i,i)</span><br><span class="line">        getString(i,i+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">i,j</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>((i&gt;=<span class="number">0</span>) &amp;&amp; (j&lt;s.length) &amp;&amp; (s[i]===s[j]))&#123;</span><br><span class="line">            i--,j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j-i-<span class="number">1</span>&gt;res.length)&#123;</span><br><span class="line">            res=s.slice(i+<span class="number">1</span>,j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28. 实现strStr()"></a>28. 实现strStr()</h4><div class="note default modern"><p>实现 strStr() 函数。<br>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。</p></div><p>其实这就是实现indexOf()</p><p>刚开始我的思路时，一旦遇到一个字符和needle的第一个字符相等，就开始while循环，直到不相等退出，然后使后一个字符串从0开始搜索，钱一个字符串接着退出的位置继续搜索</p><p>但是这样其实是存在问题的，比如<code>ississip</code>中<code>issip</code>第一次出现的位置，按上面的算法是无法找到的，因为已经访问过的无法再访问的位置包含了目标位置</p><p>所以：</p><ol><li><p>可以for循环，每遇到一个与heedle第一个字符相等的字符就从它开始for循环匹配</p></li><li><p>KMP算法 有空再看…</p></li></ol><p><br></p><h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h4><div class="note default modern"><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p>输入: strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p></div><p>捋清思路很重要！！</p><p>判断打乱顺序的字符串是否包含相同字符且字符数量相同，要想到<strong>排序</strong></p><p>按字典序排序（也就是用sort）之后，是否相等就可以直接判断了</p><p>但是我们最终需要的是原先的字符串分类组合在一起的数组，所以<strong>首先想到</strong>，可以通过将排序后相同的字符串的<strong>下标</strong>记录在一起，要怎么记录呢？用排序后的<strong>字符串作索引</strong>来记录！然后<strong>for…in</strong>来扫描属性，将下标对应的字符串push到一个数组中，大功告成。</p><p>接下来分两种不同的方法：</p><ol><li>创建一个<strong>对象</strong>，对象的属性名为排序后的字符串，属性值为一个数组，里面包含的是排序后与该属性相同的字符串在原始数组里的下标。<br><strong>怎么对字符串进行排序</strong>？转成数组进行sort再转回字符串：<code>Array.from(str).sort().join(&#39;&#39;)</code><br><strong>进一步思考：</strong>那既然可以放下标，那干脆直接放<strong>放字符串</strong>吧，这样就可以通过<strong><code>Object.values(属性)</code></strong>获得最终的结果啦！<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> groupAnagrams = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="built_in">Array</span>.from(strs[i]).sort().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        obj[str] ? obj[str].push(strs[i]) : obj[str] = [strs[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.values(obj)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><code>obj[str] ? obj[str].push(strs[i]) : obj[str] = [strs[i]]</code><br>这句代码是判断obj中是否包含属性str，如果包含，则将当前字符串push到str对应的数组中，否则创建一个数组并将str给push进去</li><li>创建一个<strong>map</strong>，使用map的get和set方法，与创建对象类似的思路<br>map.<strong>get</strong>(key)返回key属性对应的属性值，map.<strong>set</strong>(key,value)设置属性为key的属性值为value，map.<strong>values</strong>()返回map中所有的属性值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> strs) &#123;</span><br><span class="line">  <span class="keyword">let</span> key = <span class="built_in">Array</span>.from(str).sort().join()</span><br><span class="line">  map.get(key) ? map.set(key, [...map.get(key), str]) : map.set(key, [str])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.from(map.values())</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><div class="note default modern"><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>输入：nums = [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</p></div><p>我解决这个问题的思路是，遍历去重排序（<strong>set和sort</strong>），然后判断前一个数是否为该数减1，然后令一个<strong>变量递增</strong>，记录变量在这个过程中的最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestConsecutive = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!nums.length) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  nums=<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(nums))</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;<span class="keyword">return</span> a-b&#125;)</span><br><span class="line">  <span class="keyword">let</span> n=nums.length,res=<span class="number">1</span>,tem=<span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i-<span class="number">1</span>]===nums[i]-<span class="number">1</span>)&#123;</span><br><span class="line">      tem++</span><br><span class="line">      res=<span class="built_in">Math</span>.max(res,tem)</span><br><span class="line">    &#125;<span class="keyword">else</span> tem=<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实也可以不排序，使用<strong>map</strong>存储数，当判断该数-1的值是否存在时，直接判断其是否在map中即可</p><p><br></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><p>可以点开看看题，一定要抓住题干的和细节和要求，升序排列的数组，且不重复</p><p>那么我们第一想到的思路是<b>判断与前一个数的关系</b>，但是如果有很多个相同的数呢，一一判断吗？不，所以我们需要一个变量来暂存当前比较的过程中<b>相同数的第一个数的下标p</b>之后的位置，需要一个变量i不断获取数然后比较，当之后出现与p处不同的数nums[i]时，将这个不同的数赋值给nums[p]<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> p=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            nums[p]=nums[i]</span><br><span class="line">            p++</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    nums=nums.slice(<span class="number">0</span>,p)</span><br><span class="line">    <span class="keyword">return</span> nums.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><div class="note default modern"><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p></div><p>虽说是做图像/矩阵题，但是<strong>不一定要将目光放在矩阵图上</strong>，这样很容易钻牛角。在尝试将目光转向数组之后，豁然开朗</p><p>[15,13,2,5] 是否就是每个二维数组的第一个元素抽离出来进行<strong>组合再翻转</strong>的结果呢？</p><p>列要变行，则每一个数组（每一行）的第一个元素组合就变成了新的第一行。</p><p>不允许使用另一个矩阵，那我们就可以将新的数组<strong>push</strong>到原矩阵数组中，在最后<strong>splice</strong>掉之前的数组，这样就大功告成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n=matrix.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> arr=[]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            arr.push(matrix[j][i])</span><br><span class="line">        &#125;</span><br><span class="line">        matrix.push(arr.reverse())</span><br><span class="line">    &#125;</span><br><span class="line">    matrix.splice(<span class="number">0</span>,n)</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><div class="note default modern"><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p></div><p><strong>第一种方法：</strong></p><p>先按左坐标升序排序，然后一遇到重叠的区间（左边点的右坐标大于右边点的左坐标）就将其合并，继续向后排查，直到到达数组末</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    intervals.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;intervals.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;=intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">let</span> [x,y]=[intervals[i][<span class="number">0</span>],<span class="built_in">Math</span>.max(intervals[i][<span class="number">1</span>],intervals[i+<span class="number">1</span>][<span class="number">1</span>])]</span><br><span class="line">            intervals.splice(i,<span class="number">2</span>,[x,y])</span><br><span class="line">        &#125;<span class="keyword">else</span> i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>第二种方法：</strong></p><p>大方向与第一种方法类似，但这个方法中while(i&lt;nums.length)时，遇到重叠区间时并不将其合并，而是<strong>一直记录</strong>最大的右坐标right，再次利用<strong>while循环</strong>查找左坐标比right小的点，直到遇到左坐标大于right的点，然后跳出循环，利用<code>splice</code>函数删除起始点到当前点的所有坐标并插入新生成的坐标（即right和起始点的left相结合形成的点），<strong>注意</strong>要记得修改指向起始点的i，因为在第二层while循环中的i是一直递增的，而在splice中会删除若干节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span></span><br><span class="line">    intervals.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">while</span>(i&lt;intervals.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> start=i</span><br><span class="line">        <span class="keyword">let</span> left=intervals[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> right=intervals[i][<span class="number">1</span>]</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=intervals.length-<span class="number">1</span> &amp;&amp; right&gt;=intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">            right=<span class="built_in">Math</span>.max(right,intervals[i][<span class="number">1</span>])</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i-start&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            intervals.splice(start,i-start,[left,right])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面这行之前一直没加，如果不修改i的值的话，i相当于多个需要删除的数组之后的索引</span></span><br><span class="line">        i=start+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h2><div class="note default modern"><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>必须在不使用库的sort函数的情况下解决这个问题。</p><p>输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2]</p></div><p>做吐了，做了将近一天</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tem=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> t=nums[tem]</span><br><span class="line">            nums[tem]=<span class="number">0</span></span><br><span class="line">            nums[i]=t</span><br><span class="line">            tem++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=tem;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]===<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> t=nums[tem]</span><br><span class="line">            nums[tem]=<span class="number">1</span></span><br><span class="line">            nums[i]=t</span><br><span class="line">            tem++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种：（又困又看不懂）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> zero=<span class="number">0</span>,two=nums.length-<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=two &amp;&amp; nums[i]===<span class="number">2</span>)&#123;</span><br><span class="line">            nums[i]=nums[two]</span><br><span class="line">            nums[two]=<span class="number">2</span></span><br><span class="line">            two--</span><br><span class="line">            <span class="comment">// 注意，这儿没有i++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]===<span class="number">0</span>)&#123;</span><br><span class="line">            nums[i]=nums[zero]</span><br><span class="line">            nums[zero]=<span class="number">0</span></span><br><span class="line">            zero++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><div class="note default modern"><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p></div><p>美团一面的笔试题，要掌握这个思路，从大的数开始比较，使用双指针，将较大的放在数组的后面，一直到某个数组遍历完成（nums1不需要再次判断，因为nums1就是要返回的数组）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> l=m-<span class="number">1</span>,r=n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> p=m+n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; r&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[l]&gt;nums2[r])&#123;</span><br><span class="line">            nums1[p]=nums1[l]</span><br><span class="line">            l--</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums1[p]=nums2[r]</span><br><span class="line">            r--</span><br><span class="line">        &#125;</span><br><span class="line">        p--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        nums1[p]=nums2[r]</span><br><span class="line">        r--</span><br><span class="line">        p--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h2><div class="note default modern"><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p></div><ol><li>使用两个数组，一个存正数，一个存负数，最后用indexOf查找值为1的</li><li>使用集合，若集合中有该数就删除，如果没有就添加，最后剩下的就是所要求的</li><li>计算所有数之和以及出现过的数的2倍和，相减就是所求的数</li><li>【秒哉】使用<strong>异或</strong>，相同的数异或是0，数和0异或之后还是该数，该题中只有一个数会出现一次，其余的均出现两次，所以将所有数异或，最后得到的就是所求的</li></ol><p><br></p><h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><div class="note default modern"><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：<br>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p></div><p><a target="_blank" rel="noopener" href="https://picgoxl.oss-cn-beijing.aliyuncs.com/img/Snipaste_2022-04-01_09-50-21.png">https://picgoxl.oss-cn-beijing.aliyuncs.com/img/Snipaste_2022-04-01_09-50-21.png</a></p><p>这道题的思路很重要，如果我们从左上角开始搜索的话，向右或者向下都是增加，那么我们选择哪个方向呢？回溯？递归？</p><p>不，如果我们选择另一种方向，<strong>从右上角开始搜索</strong>，我们会发现，<strong>向左是递减，向下是递增</strong>的，那么我们就可以根据其与当前数的大小关系来选择向左还是向下，这样就可以将整个图表很好的利用起来了~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,j=matrix[<span class="number">0</span>].length-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; i&lt;matrix.length &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; j&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">      <span class="keyword">if</span>(target===matrix[i][j])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;matrix.length &amp;&amp; target&gt;matrix[i][j])&#123;</span><br><span class="line">          i++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; i&lt;matrix.length &amp;&amp; target&lt;matrix[i][j])&#123;</span><br><span class="line">          j--</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="769-最多能完成排序的块"><a href="#769-最多能完成排序的块" class="headerlink" title="769. 最多能完成排序的块"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/">769. 最多能完成排序的块</a></h2><p>抓住题中给出的特殊条件，<strong>无重复，[0,n-1]</strong></p><p>刚开始看到题时的大体思路是记录当前的最大字符，当遇到比自己小的字符就继续向后走，当遇到比自己大的字符时，意味着可以进行分割，res++。</p><p>看上去好像没毛病，<strong>但是</strong>你是否有考虑到遇到更大的字符后面是比这俩字符都小的字符呢？ 比如[1,2,0,3,4] 这种情况下，1、2、0只能是一个块，所以这种思路是存在漏洞的。</p><p>我们再看题，无重复，[0,n-1]，是否意味着如果按顺序的话,arr[i]就总是会处在i处呢？对。那当它不在这时是什么情况呢？</p><p><strong>如果一个字符i是当前的最大字符的话，那么它一定在i位置之前并且它后面存在比它小的字符</strong>，如果在i位置之后它不可能是当前最大字符，那么当从它继续向后走，到达i处时（此时它如果仍是最大字符），就可以进行一次分割了，<strong>因为后面不会再有比它小的数字了</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxChunksToSorted = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i=<span class="number">0</span>,res=<span class="number">0</span>,max=-<span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span>(i&lt;arr.length)&#123;</span><br><span class="line">    max=<span class="built_in">Math</span>.max(max,arr[i])</span><br><span class="line">    <span class="keyword">if</span>(max===i)&#123;</span><br><span class="line">      res++</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><div class="note default modern"><p>给你一个链表的头节点 head ，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p></div><p>使用快慢指针，如果快的追上慢的，说明有环；还需要注意特殊情况比如right.next、right.next.next是否为null<br>(下面部分代码省略了树结构)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left=head,right=head</span><br><span class="line">    <span class="keyword">while</span>(right)&#123;</span><br><span class="line">        left=left.next</span><br><span class="line">        <span class="keyword">if</span>(!right.next || !right.next.next)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        right=right.next.next</span><br><span class="line">        <span class="keyword">if</span>(left===right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><div class="note default modern"><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p></div><p>先存在数组中，然后根据长度是奇数还是偶数来进行不同的操作<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=[],l,r</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        arr.push(head.val)</span><br><span class="line">        head=head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr.length%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">        r=arr.length/<span class="number">2</span></span><br><span class="line">        l=r-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> center=<span class="built_in">parseInt</span>(arr.length/<span class="number">2</span>)</span><br><span class="line">        l=center-<span class="number">1</span>,r=center+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; r&lt;arr.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[l]!==arr[r])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        l--,r++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></h2><p>方法一：值替换，最后使最后一个节点之前的节点的next为null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> front=node</span><br><span class="line">    <span class="keyword">while</span>(node.next)&#123;</span><br><span class="line">        node.val=node.next.val</span><br><span class="line">        front=node</span><br><span class="line">        node=node.next</span><br><span class="line">    &#125;</span><br><span class="line">    front.next=<span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：使当前值等于下一个节点的值，删除下一个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.val=node.next.val</span><br><span class="line">    node.next=node.next.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><div class="note default modern"><p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p></div><p>多写几遍，要注意代码和思路的整体性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    check(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            check(node.left)</span><br><span class="line">            res.push(node.val)</span><br><span class="line">            check(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h2><div class="note default modern"><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p></div><p>搜索树的种类与序列放置什么数字无关，只与序列的长度有关</p><p>而且对于每个节点，需要计算其子树的情况，具有重复子问题的性质，所以可以使用动态规划：<strong>枚举长度，对于每个长度来说，枚举根节点</strong>（因为不同的数字作为根节点，即使形状跟之前的相同，也是不同的情况）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var numTrees = function(n) &#123;</span><br><span class="line">  let arr=new Array(n+1).fill(0)</span><br><span class="line">  arr[0]=1,arr[1]=1</span><br><span class="line">  for(let len=2;len&lt;=n;len++)&#123;//枚举长度</span><br><span class="line">    for(let r=1;r&lt;=len;r++)&#123;//枚举根</span><br><span class="line">      arr[len]+=arr[r-1]*arr[len-r]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树*"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树<em>*</em></a></h2><p>这道题真的需要反复揣摩，多做多想！</p><p>我在做这道题的时候，遇到的令我很困惑的问题是<strong>如何区分左子树的左节点和右子树的左节点？</strong> 因为二者需要判断的条件不同，前者只需要考虑值小于父节点，而后者需要考虑值小于父节点且大于祖先节点</p><p>带着这种困惑，我去阅读了题解，好家伙，其实我的解题方向是对的，需要为递归函数传入两个值参数，用来进行值判断，但是我考虑的太细化了，并没有从整体的方面考虑，接下来看看正确思路：</p><p>我们首先从<strong>整体的方向</strong>去考虑这个问题，对于根的左节点来说，它们需要满足的条件就是小于根节点的值，对于根的右节点来说，它们需要满足的条件就是大于根节点的值，所以，<strong>对于每个节点来说，它们都存在自己的边界值</strong>，这句话很关键，边界值，min和max，如何区分不同的情况呢？</p><p><strong>把它们全都推到一个水平线上去看！</strong></p><p>对于<strong>左节点</strong>来说，如果是根左边的左节点，其边界值就是[-infinity,父节点的值]，如果是根右边的左节点，其边界值就是[祖先节点的值，父节点的值]</p><p>对于<strong>右节点</strong>来说，如果是根左边的右节点，其边界值就是[父节点的值，祖先节点的值]，如果是根右边的右节点，其边界值就是[父节点的值,infinity]</p><p>所以我们在调用递归函数时，就可以传入一个lower和upper，表示<strong>当前节点的边界值</strong>，初始为[-infinity,infinity]，随着递归的调用，对于<strong>左节点</strong>来说，其<strong>右边界值永远都是父节点的值</strong>，其<strong>左边界就是继承之前的左边界值</strong>；对于<strong>右节点</strong>来说，其<strong>左边界永远是父节点的值</strong>，其<strong>右边界就是继承之前的有边界值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fun(root,-<span class="literal">Infinity</span>,<span class="literal">Infinity</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">node,l,r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(node.val&lt;=l || node.val&gt;=r) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> fun(node.left,l,node.val) &amp;&amp; fun(node.right,node.val,r)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><div class="note default modern"><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p></div><p>需要注意的就是特殊情况的判断，如两个node都为空或者有一个node为空一个不为空；仍然需要注意<strong>整体性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root.left &amp;&amp; !root.right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res=check(root.left,root.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">node1,node2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node1 &amp;&amp; !node2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">if</span>(!node1 || !node2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> l=check(node1.left,node2.right)</span><br><span class="line">        <span class="keyword">let</span> r=check(node1.right,node2.left)</span><br><span class="line">        <span class="keyword">if</span>(node1.val===node2.val &amp;&amp; l &amp;&amp; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><div class="note default modern"><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p></div><p>如果没有节点，深度为0</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=<span class="number">0</span></span><br><span class="line">    check(root,<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">node,depth</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            res=<span class="built_in">Math</span>.max(res,depth)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        check(node.left,depth+<span class="number">1</span>)</span><br><span class="line">        check(node.right,depth+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226. 反转二叉树"></a>226. 反转二叉树</h2><div class="note default modern"><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p></div><p>多琢磨这个思想，<strong>递归</strong><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(node.left)</span><br><span class="line">        reverse(node.right)</span><br><span class="line">        <span class="keyword">let</span> tem=node.left</span><br><span class="line">        node.left=node.right</span><br><span class="line">        node.right=tem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>更简洁的版本,直接调用该函数本身一直递归：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    invertTree(root.left)</span><br><span class="line">    invertTree(root.right)</span><br><span class="line">    <span class="keyword">let</span> tem=root.left</span><br><span class="line">    root.left=root.right</span><br><span class="line">    root.right=tem</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="545-二叉树的直径"><a href="#545-二叉树的直径" class="headerlink" title="545. 二叉树的直径"></a>545. 二叉树的直径</h2><div class="note default modern"><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p></div><p>注意读题！可能不穿过根节点。所以要记录l+r的最大值<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">0</span></span><br><span class="line">    getLong(root)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getLong</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> l=getLong(node.left)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> r=getLong(node.right)+<span class="number">1</span></span><br><span class="line">        num=<span class="built_in">Math</span>.max(num,l+r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(l,r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先**"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先**</a></h2><p>要首先弄明白，整个递归函数需要返回的是什么</p><p><strong>应该是一个节点node</strong>，如果node就等于指定的节点之一，则返回node</p><p>否则递归查找node左右子节点，如果左右子节点的返回值均不为空，说明各自都包含指定节点，返回node；如果有一个不为空，说明一个包含一个不包含，则返回不为空的节点；如果都为空，说明一个也不包含，返回null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">q</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun(root)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node==p || node==q)&#123;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> left=fun(node.left,p,q)</span><br><span class="line">        <span class="keyword">let</span> right=fun(node.right,p,q)</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left==<span class="literal">null</span>?right:left</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="递归-回溯"><a href="#递归-回溯" class="headerlink" title="递归 回溯"></a>递归 回溯</h1><h2 id="17-电话号码的字母结合"><a href="#17-电话号码的字母结合" class="headerlink" title="17. 电话号码的字母结合"></a>17. 电话号码的字母结合</h2><div class="note default modern"><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射与电话按键相同，注意 1 不对应任何字母。</p></div><p>可能算是第一次把回溯写出来，其实好像也不难</p><p>首先要搞清楚为什么需要回溯？</p><p>在这道题里面，如果指定输入数字的长度，其实是可以用循环的，但是并没有，所以你需要自行判断什么时候到达末尾，且在逐步到达末尾的过程中，你需要做一些操作来获得所要求的东西</p><p>回溯先是尝试一条路走到黑，然后退回一步，寻找其他出路，再次走到黑，再次回退，直到走遍所有路</p><div class="note info flat"><p>回溯函数中需要指定走到的层数以及在这个过程中一直被修改和引用的变量；在回溯函数开头还需要添加判断是否走到尽头的函数：如果是，则做一些操作、返回；如果不是，则继续向下走</p></div><p>如下是这道题的回溯函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recall</span>(<span class="params">floor,str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(floor===digits.length)&#123;</span><br><span class="line">        res.push(str)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> n=<span class="built_in">Number</span>(digits[floor])</span><br><span class="line">    <span class="keyword">let</span> t=nums[n-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;t.length;i++)&#123;</span><br><span class="line">        str += t[i]</span><br><span class="line">        recall(floor+<span class="number">1</span>,str)</span><br><span class="line">        str = str.slice(<span class="number">0</span>, str.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><div class="note default modern"><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p></div><p>绝了，又忘记<strong>slice不会改变原字符串</strong>了，substr也不会</p><ul><li><p><strong>slice</strong>(start,end) 不包括end 提取字符串的片断并返回，不改变原字符串</p></li><li><p><strong>substr</strong>(start,length) 从起始索引号提取字符串中指定数目的字符</p></li></ul><ol><li><p>暴力解法-回溯</p><p>传入的floor最初是0，floor为1时str为’(‘才符合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=[]</span><br><span class="line">    generate(<span class="string">&#x27;&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">str,floor</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(floor===<span class="number">2</span>*n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(str))&#123;</span><br><span class="line">                res.push(str)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        str+=<span class="string">&#x27;(&#x27;</span></span><br><span class="line">        generate(str,floor+<span class="number">1</span>)</span><br><span class="line">        str=str.slice(<span class="number">0</span>,str.length-<span class="number">1</span>)</span><br><span class="line">        str+=<span class="string">&#x27;)&#x27;</span></span><br><span class="line">        generate(str,floor+<span class="number">1</span>)</span><br><span class="line">        str=str.slice(<span class="number">0</span>,str.length-<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">valid</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]===<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>带条件约束的回溯</p><p>满足’(‘数量小于n时可以添加’(‘；满足’)’数量&lt;’(‘时，可以添加’)’</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=[]</span><br><span class="line">    generate(<span class="string">&#x27;&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">str,floor</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(floor===<span class="number">2</span>*n)&#123;</span><br><span class="line">            res.push(str)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> l=<span class="number">0</span>,r=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]===<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                l++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;n)&#123;</span><br><span class="line">            str+=<span class="string">&#x27;(&#x27;</span></span><br><span class="line">            generate(str,floor+<span class="number">1</span>)</span><br><span class="line">            str=str.substr(<span class="number">0</span>,str.length-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">            str+=<span class="string">&#x27;)&#x27;</span></span><br><span class="line">            generate(str,floor+<span class="number">1</span>)</span><br><span class="line">            str=str.substr(<span class="number">0</span>,str.length-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列**"></a>31. 下一个排列**</h2><div class="note default modern"><p>整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p>输入：nums = [1,2,3]输出：[1,3,2]</p></div><p>求一个数组按<strong>字典序排序</strong>的下一个数组的方法是：</p><ol><li><strong>从右往左</strong>找一个较小值a[i]，使得a[i]小于a[i+1]，此时a[i]右侧即为下降序列</li><li>然后从右往左找一个大于a[i]的值a[j]，保证是<strong>大于a[i]的值中的较小值</strong></li><li>交换a[i]和a[j]，然后需要a[j]右侧是从小到大的顺序。</li></ol><p>我们可以对a[j]右侧的数组进行<strong>排序</strong>，使其变化的幅度尽量小；</p><p>但！ <strong>注意！</strong>更简便的方法是：<br>由于在交换之前，a[i]右侧为降序序列，所以交换之后，我们只需要对a[j]后面的数组进行<strong>reverse</strong>，使其升序排列即可.</p><p>我们希望的是，使得较小值尽量靠右，较大值尽量靠左，交换二者后，将交换后较大值右边的按从小到大排序，减少整体变大幅度</p><p>数组的concat函数不修改原数组，arr.concat(nums)，是将arr和nums连接起来，返回连接后的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> nextPermutation = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n=nums.length</span><br><span class="line">    <span class="keyword">let</span> num=n-<span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> l,r</span><br><span class="line">    <span class="keyword">while</span>(num&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[num]&lt;nums[num+<span class="number">1</span>])&#123;</span><br><span class="line">            l=num</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        nums.reverse()</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        num=n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(num&gt;l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[num]&gt;nums[l])&#123;</span><br><span class="line">                r=num</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> t=nums[l]</span><br><span class="line">        nums[l]=nums[r]</span><br><span class="line">        nums[r]=t</span><br><span class="line">        <span class="keyword">let</span> arr=nums.splice(l+<span class="number">1</span>,n-l-<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(arr)</span><br><span class="line">        arr.reverse()</span><br><span class="line">        nums.push(...arr)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> nextPermutation = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n=nums.length</span><br><span class="line">    <span class="keyword">let</span> l=n-<span class="number">2</span>,r=n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; nums[l]&gt;=nums[l+<span class="number">1</span>])&#123;</span><br><span class="line">        l--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.reverse()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;l &amp;&amp; nums[r]&lt;=nums[l])&#123;</span><br><span class="line">            r--</span><br><span class="line">        &#125;</span><br><span class="line">        [nums[l],nums[r]]=[nums[r],nums[l]]</span><br><span class="line">        <span class="keyword">let</span> arr=nums.splice(l+<span class="number">1</span>,n-l-<span class="number">1</span>)</span><br><span class="line">        arr.reverse()</span><br><span class="line">        nums.push(...arr)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和**"></a>39. 组合总和**</h2><div class="note default modern"><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]]<br>输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]]</p></div><p>暴力<strong>搜索回溯</strong>，没有剪枝，每次都判断是选择当前数值加入还是下一个数值；要注意，在选择当前数值加入时，<strong>不要</strong>arr.push()，这样会导致栈溢出，直接在调用函数中使用展开运算符直接将数组传过去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum = <span class="function"><span class="keyword">function</span>(<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n=candidates.length</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>,[])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i,num,arr</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n || num&gt;target)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num===target)&#123;</span><br><span class="line">            res.push(arr)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(i,num+candidates[i],[...arr,candidates[i]])</span><br><span class="line">        dfs(i+<span class="number">1</span>,num,arr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><div class="note default modern"><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p></div><p>需要注意的是 全排列需要判断已经排列好的数组arr中是否包含当前数，如果包含则跳过；在判断数组arr长度===给定数组nums长度时，需要对数组arr进行深拷贝，复制到res数组中，否则在之后pop操作后，res中数组中的数也将被pop，结果会是一串空数组。</p><p>第一层深拷贝可以用：…、slice、concat</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n=nums.length</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    calculate([])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length===n)&#123;</span><br><span class="line">            res.push([...arr])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr.includes(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            arr.push(nums[i])</span><br><span class="line">            calculate(arr)</span><br><span class="line">            arr.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集**"></a>78. 子集**</h2><div class="note default modern"><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p></div><p>有事没事就多做几次，一定要注意<strong>递归的时候传入的参数</strong>到底是什么！</p><p>尽管理解了背后的原理，还是要自己多亲手实践，要不然都不知道问题出在哪里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">let</span> arr=[]</span><br><span class="line">    fun(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">floor</span>)</span>&#123;</span><br><span class="line">        res.push([...arr])</span><br><span class="line">        <span class="keyword">if</span>(floor&gt;=nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=floor;i&lt;nums.length;i++)&#123;</span><br><span class="line">            arr.push(nums[i])</span><br><span class="line">            fun(i+<span class="number">1</span>)<span class="comment">//一定要记住是i+1，不是floor+1</span></span><br><span class="line">            arr.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h2><div class="note default modern"><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p></div><p>总的思路还是使用回溯，当在某字符的基础上回溯时，记得将该字符置空，防止重复使用。</p><p>首先需要判断<strong>矩阵中每一个字符</strong>与word第一个字符是否相同，如果<strong>相同再选择进入回溯</strong>；在回溯中，要记录现在正在进行比较的word字符的下标index，因为只有当当前字符等于word中某字符时它才会进入回溯，所以我们可以<strong>直接对其上下左右的字符进行判断</strong>，如果它上下左右中某字符<strong>合法且等于word[index]</strong>，那么就进行下一层回溯（回溯中需要传递的<strong>参数</strong>有：在矩阵中的<strong>坐标</strong>，word当前比较字符的<strong>下标</strong>以及当前已经拥有的相等字符构成的<strong>字符串数组</strong>），直到在某次回溯中字符串数组等于word返回true，或者长度已超过word但不相等返回false，只要当前字符的上下左右字符有一个返回true，那么该字符的回溯就可以返回true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xx = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    yy = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> len1 = board.length,</span><br><span class="line">    len2 = board[<span class="number">0</span>].length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[i][j] === word[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> t = fun(i, j, [board[i][j]], <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x, y, str, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length === word.length &amp;&amp; str.join(<span class="string">&#x27;&#x27;</span>) == word) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.length &gt;= word.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> val = board[x][y]</span><br><span class="line">    board[x][y] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> temx = x + xx[i],</span><br><span class="line">        temy = y + yy[i]</span><br><span class="line">      <span class="keyword">if</span> (valid(temx, temy) &amp;&amp; board[temx][temy] === word[index]) &#123;</span><br><span class="line">        str.push(board[temx][temy])</span><br><span class="line">        <span class="keyword">let</span> tem = fun(temx, temy, str, index + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (tem) &#123;</span><br><span class="line">          t = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        str.pop()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    board[x][y] = val</span><br><span class="line">    <span class="keyword">return</span> t ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">valid</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="337-打家劫舍III"><a href="#337-打家劫舍III" class="headerlink" title="337. 打家劫舍III**"></a>337. 打家劫舍III**</h2><div class="note default modern"><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。</p><p>除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><p>给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p></div><p>每个节点返回的是：选择自己和孙子 or 选择儿子 中的最大值。</p><p>只要选了自己，就一定不会再选儿子</p><p><strong>第一种方法</strong>：递归，计算两个儿子的value值之和num1；然后当儿子存在时，将自己和孙子的value值相加得到num2，取num1和num2的最大值返回</p><p><strong>第二种方法</strong>：记忆化递归，优化方法一，因为在第一种方法中计算儿子的value值时，会重复计算孙子的值，所以我们使用map，将节点作为属性，记录各节点的最大value值，当需要计算某节点的value值时，先<code>map.has(node)</code>，如果存在则直接返回<code>map.get(node)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">return</span> getval(root)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getval</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map.has(node))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(node)</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(node.left,getval(node.left))</span><br><span class="line">        map.set(node.right,getval(node.right))</span><br><span class="line">        <span class="keyword">let</span> num1=map.get(node.left)+map.get(node.right)</span><br><span class="line">        <span class="keyword">let</span> num2=node.val</span><br><span class="line">        <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">            num2 += getval(node.left.left)+getval(node.left.right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">            num2 += getval(node.right.left)+getval(node.right.right)</span><br><span class="line">        &#125;</span><br><span class="line">        num2=<span class="built_in">Math</span>.max(num2,num1)</span><br><span class="line">        map.set(node.num2)</span><br><span class="line">        <span class="keyword">return</span> num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>第三种方法</strong>：思考一下，发现<strong>每次的比较只涉及父儿孙三代</strong>，所以我们在计算儿子的value值时，顺便将儿子和孙子的value都记录下来，返回，就不需要再去单独计算孙子的值了。</p><p>所以我们无需记录所有节点的value值，只需要记录每三代的value值就可以了，可以通过计算儿子时返回一个包含儿子和孙子的value值的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=getval(root)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(res[<span class="number">0</span>],res[<span class="number">1</span>])</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getval</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> l=getval(node.left)</span><br><span class="line">        <span class="keyword">let</span> r=getval(node.right)</span><br><span class="line">        <span class="keyword">let</span> num1=<span class="built_in">Math</span>.max(l[<span class="number">0</span>],l[<span class="number">1</span>])+<span class="built_in">Math</span>.max(r[<span class="number">0</span>],r[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">let</span> num2=node.val+l[<span class="number">0</span>]+r[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> [num1,num2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><div class="note default modern"><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。</p></div><p><b>贪心算法</b>，需要维持一个<b>最远可以到达的距离</b></p><p>不能根据0在哪、考虑0前的数来解决，因为你无法确定0前面的哪一个是最优的；但如果你维护一个最远距离，即使碰到0也没关系，只要你目前访问的数在该最远距离范围内即可，一旦碰到不在范围内的，说明无法到达</p><p>比如输入：nums = [3,2,1,0,4]；输出：false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.indexOf(<span class="number">0</span>)===-<span class="number">1</span> || nums.length===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> maxDis=nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=maxDis)&#123;</span><br><span class="line">            maxDis=<span class="built_in">Math</span>.max(maxDis,nums[i]+i)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="56-合并区间-1"><a href="#56-合并区间-1" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><div class="note default modern"><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p></div><blockquote><p><b>第一种方法：</b></p></blockquote><p>先按左坐标升序排序，然后一遇到重叠的区间（左边点的右坐标大于右边点的左坐标）就将其合并，继续向后排查，直到到达数组末</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    intervals.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;intervals.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;=intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">let</span> [x,y]=[intervals[i][<span class="number">0</span>],<span class="built_in">Math</span>.max(intervals[i][<span class="number">1</span>],intervals[i+<span class="number">1</span>][<span class="number">1</span>])]</span><br><span class="line">            intervals.splice(i,<span class="number">2</span>,[x,y])</span><br><span class="line">        &#125;<span class="keyword">else</span> i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>第二种方法：</strong></p><p>大方向与第一种方法类似，但这个方法中while(i&lt;nums.length)时，遇到重叠区间时并不将其合并，而是<strong>一直记录</strong>最大的右坐标right，再次利用<strong>while循环</strong>查找左坐标比right小的点，直到遇到左坐标大于right的点，然后跳出循环，利用<code>splice</code>函数删除起始点到当前点的所有坐标并插入新生成的坐标（即right和起始点的left相结合形成的点），<strong>注意</strong>要记得修改指向起始点的i，因为在第二层while循环中的i是一直递增的，而在splice中会删除若干节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span></span><br><span class="line">    intervals.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">while</span>(i&lt;intervals.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> start=i</span><br><span class="line">        <span class="keyword">let</span> left=intervals[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> right=intervals[i][<span class="number">1</span>]</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=intervals.length-<span class="number">1</span> &amp;&amp; right&gt;=intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">            right=<span class="built_in">Math</span>.max(right,intervals[i][<span class="number">1</span>])</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i-start&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            intervals.splice(start,i-start,[left,right])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面这行之前一直没加，如果不修改i的值的话，i相当于多个需要删除的数组之后的索引</span></span><br><span class="line">        i=start+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a></h2><div class="note default modern"><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。<br>你需要按照以下要求，给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p></div><p>因为每个孩子的糖果数会受左右两边的影响，所以我们可以想到使用两次遍历的方法，从左到右，从右到左；</p><p>从左到右时，比较第i与i-1，因为此时i-1的数目是暂时确定的（不能比i与i+1，因为i+1现在还没比），而且如果第i比i-1分数高的话，那么res[i]应该是在res[i-1]基础上加1，而不是单纯加1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">ratings</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> candy = <span class="function"><span class="keyword">function</span>(<span class="params">ratings</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n=ratings.length</span><br><span class="line">    <span class="keyword">let</span> res=<span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>] &amp;&amp; res[i]&lt;=res[i-<span class="number">1</span>])&#123;</span><br><span class="line">            res[i]=res[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> num=res[n-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i]&gt;ratings[i+<span class="number">1</span>] &amp;&amp; res[i]&lt;=res[i+<span class="number">1</span>])&#123;</span><br><span class="line">            res[i]=res[i+<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        num+=res[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a>406. 根据身高重建队列</h2><div class="note default modern"><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p></div><ol><li>身高从小到大排，身高相同的时候要按k的值从大到小排，这样才不会让身高相同的情况影响最后的摆放；关键的点是将这个人放在第k+1个位置上（但实际上可能在k+1往后），使得之前能够空下k个位置放比他大的，所以我们在从前往后数这个人位置的时候，一定是<strong>空下的位置</strong>多一个才算一个，因为是按照排序摆放的，所以先摆放的人身高要较低，不能算在k值减小的数中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reconstructQueue = <span class="function"><span class="keyword">function</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">    people.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]===b[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">1</span>]-a[<span class="number">1</span>]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> len=people.length</span><br><span class="line">    <span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">0</span>).map(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="built_in">Array</span>())</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> num=people[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">let</span> t=-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(num&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            t++</span><br><span class="line">            <span class="comment">//一定得是arr[t]为空才能将num-1，这样才能空下位置摆放比该人高的人   </span></span><br><span class="line">            <span class="keyword">if</span>(!arr[t].length)&#123;</span><br><span class="line">                num--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[t]=people[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>身高从大到小排，这样排好序之后摆放的时候就直接按顺序和k值插入即可，因为在这个人之前的所有人身高都比这个人高，这样就只需要考虑k是否满足<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> reconstructQueue = <span class="function"><span class="keyword">function</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">    people.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]===b[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> b[<span class="number">0</span>]-a[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> arr=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">        arr.splice(people[i][<span class="number">1</span>],<span class="number">0</span>,people[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></li></ol><p><br></p><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h2><p>这道题的教训是js的<strong>sort函数</strong>，如果针对的是数字，他不会按大小排序，而是每一位的大小（类似字典序那种），所以想要按真正的大小排序的话，一定要<code>sort((a,b)=&gt;&#123;return a-b&#125;)</code></p><p><br></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="52-不同路径"><a href="#52-不同路径" class="headerlink" title="52. 不同路径"></a>52. 不同路径</h2><div class="note default modern"><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径?</p></div><p>建一个二维数组且附初值的方法：</p><p><code>new Array(m).fill(0).map(()=&gt;new Array(n).fill(0))</code></p><p>上面是正确的，修改arr[0][0]后，其他的值不会变；但是下面这个如果修改了arr[0][0]，arr[1][0]、arr[2][0]都会发生相同的变化：</p><p><code>new Array(m).fill(new Array(n).fill(0))</code></p><p>还没搞明白是为啥…</p><p>解法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>).map(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        arr[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        arr[<span class="number">0</span>][i]=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            arr[i][j] += arr[i][j-<span class="number">1</span>] + arr[i-<span class="number">1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h2><div class="note default modern"><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br><strong>子数组</strong> 是数组中的一个连续部分</p></div><p>因为我们需要的是最大和的<strong>连续</strong>子数组，我们无法确定最大的连续子数组会包含哪些数，所以我们需要求出<strong>每个数</strong>被包含时的最大子数组，又因为无法确定当前查询的数在包含它的最大子数组中的位置，所以我们暂定其为<strong>末尾</strong></p><p>所以我们目前需要求的就是以每个数为结尾的最大子数组和</p><p>那么此时就可以想到<strong>动态规划</strong>了，大问题可以拆分为小问题求解：以目前的数为结尾的最大子数组和与他前面的数的最大子数组和息息相关，该数的最大子数组和=Math.max(前面的数的最大子数组和+该数，该数)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> res=nums[<span class="number">0</span>]</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">item</span> =&gt;</span>&#123;</span><br><span class="line">        pre=<span class="built_in">Math</span>.max(item,item+pre)</span><br><span class="line">        res=<span class="built_in">Math</span>.max(res,pre)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h2><p>和52很类似的解法，只不过52求最值，这一道是求：和的最值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m=grid.length</span><br><span class="line">    <span class="keyword">let</span> n=grid[<span class="number">0</span>].length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            grid[i][j] += <span class="built_in">Math</span>.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><div class="note default modern"><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=[]</span><br><span class="line">    arr[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    arr[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">    arr[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        arr[i]=arr[i-<span class="number">1</span>]+arr[i-<span class="number">2</span>]</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>时间复杂度</strong>，最优为<strong>O(nlogn)</strong>，最坏为O(n²)</p><p><strong>空间复杂度</strong>(取决于递归的深度)，最优为<strong>O(logn)</strong>，最坏为O(n)</p><p>当每次划分的结果为含 ⌊n/2⌋和 ⌈n/2⌉−1 个元素时，最好情况发生，此时递归的次数为 logn，每次划分的时间复杂度为 O(n)，所以最优的时间复杂度为 O(nlogn)。</p><p>当每次划分的结果为 n-1 和 0 个元素时，最坏情况发生，此时递归的次数为 n-1，每次划分的时间复杂度为 O(n)，，所以最坏的时间复杂度为 O(n²)。</p><p>不是稳定排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fast</span>(<span class="params">nums, l, r</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归终点</span></span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> number = nums[l]</span><br><span class="line">  <span class="keyword">let</span> one = l,</span><br><span class="line">    two = r</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">while</span> (number &lt;= nums[r] &amp;&amp; l &lt; r) &#123;</span><br><span class="line">      r--</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l] = nums[r]</span><br><span class="line">    <span class="keyword">while</span> (number &gt;= nums[l] &amp;&amp; l &lt; r) &#123;</span><br><span class="line">      l++</span><br><span class="line">    &#125;</span><br><span class="line">    nums[r] = nums[l]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这一步很关键，记得将最终指向的数字赋值为最初的基准数</span></span><br><span class="line">  nums[l] = number</span><br><span class="line">  fast(nums, one, l)</span><br><span class="line">  fast(nums, l + <span class="number">1</span>, two)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">67</span>, <span class="number">133</span>, <span class="number">9</span>, <span class="number">32</span>]</span><br><span class="line">fast(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>及时终止的冒泡排序：</p><p><strong>每经历一次排序，最后一位数字的值就会被确定</strong>，所以当未被确定的数组的长度为0时，就完成冒泡排序，如果在比较的过程中，没有发生无序的情况，就说明已经排序完成，可以break</p><p>冒泡排序的<strong>平均时间复杂度为 O(n²)</strong> ，最优时间复杂度为O(n)，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length</span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    <span class="keyword">let</span> tem = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        [nums[i], nums[i + <span class="number">1</span>]] = [nums[i + <span class="number">1</span>], nums[i]]</span><br><span class="line">        tem = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tem) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>遍历当前数组，以当前访问的元素作为基准，<strong>从该元素往后的数组中选出最小或最大的元素</strong>与当前元素进行交换，直到遍历结束。</p><p>选择排序的<strong>平均时间复杂度为 O(n²)</strong> ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，不是稳定排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = i</span><br><span class="line">    <span class="keyword">let</span> res = nums[i]</span><br><span class="line">    <span class="comment">//从i向后，查找比nums[i]小的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] &lt; res) &#123;</span><br><span class="line">        res = nums[j]</span><br><span class="line">        index = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [nums[i], nums[index]] = [nums[index], nums[i]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每一步将一个待排序的记录，插入到<strong>前面</strong>已经排好序的有序序列中去，直到插完所有元素为止。（遍历时，记录当前元素A，将A与A<strong>前面排好序的序列</strong>中元素从后往前进行比较，如果当前元素A小于序列中正在访问的元素，就令前一个元素覆盖掉后一个元素的值（首先就是A前面的元素覆盖掉A），一直到找到比A大的值，然后令A为此处的值）</p><p>插入排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putIn</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    <span class="keyword">let</span> tem = nums[j]</span><br><span class="line"><span class="comment">// 与当前元素前面的序列进行比较，遇到大于该元素的就不停使前面的覆盖后面的</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; tem &lt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">      nums[j] = nums[j - <span class="number">1</span>]</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j] = tem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><div class="note default modern"><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。<br>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>输入: [3,2,1,5,6,4] 和 k = 2 输出: 5</p></div><p>根本思想还是<strong>快速排序</strong>，寻找第k个最大的元素，那么就是数组<strong>从右往左数第k个排好顺序</strong>的元素。</p><p>一次快排确定一个元素，那么就将目标<strong>k</strong>与<strong>数组长度减去该元素下标</strong>res比较，如果k较小，说明需要继续排序该元素右侧的部分，否则就排序元素左侧的部分，直到res等于k，或者整个排序结束</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length</span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">    r = len - <span class="number">1</span>,</span><br><span class="line">    res=<span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">    res = fastSort(l, r)</span><br><span class="line">    <span class="keyword">if</span> (res === len - k) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[res]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; len - k) &#123;</span><br><span class="line">      l = res + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = res - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[l]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fastSort</span>(<span class="params">l, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = nums[l]</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="keyword">while</span> (nums[r] &gt;= num &amp;&amp; l &lt; r) &#123;</span><br><span class="line">        r--</span><br><span class="line">      &#125;</span><br><span class="line">      nums[l] = nums[r]</span><br><span class="line">      <span class="keyword">while</span> (nums[l] &lt;= num &amp;&amp; l &lt; r) &#123;</span><br><span class="line">        l++</span><br><span class="line">      &#125;</span><br><span class="line">      nums[r] = nums[l]</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l] = num</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><div class="note default modern"><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2]</p></div><p>根据题意，需要返回前k个高频元素，那么我们就需要对元素进行一个划分， 每个数字都拥有其对应的出现次数，将这种一一对应的关系存放在<strong>map</strong>中，可以叫其桶排序</p><p>通过map中的get和set函数，对数组中数字进行划分，<strong>得到数字与出现次数的映射关系</strong>；然后调用<code>Array.from(map)</code>将map<strong>转为二维数组</strong>arr，再调用<strong>sort</strong>函数进行排序，最后返回arr前k个元素（这里的元素是数组）的第一个数就好啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> topKFrequent = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.get(nums[i]))&#123;</span><br><span class="line">      map.set(nums[i],map.get(nums[i])+<span class="number">1</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      map.set(nums[i],<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> arr=<span class="built_in">Array</span>.from(map)</span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b[<span class="number">1</span>]-a[<span class="number">1</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> res=[]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">    res.push(arr[i][<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="75-最小覆盖子串"><a href="#75-最小覆盖子串" class="headerlink" title="75. 最小覆盖子串"></a>75. 最小覆盖子串</h2><div class="note default modern"><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p>输入：s = “ADOBECODEBANC”, t = “ABC”输出：”BANC”</p></div><p>使用<strong>双指针</strong>，因为查找的是A中包括B中所有字符的最短子串，所以可以令指针l、r均指向0，然后令指针r一直++，直到满足包括B的条件，就令l++，直到不满足包括B的条件，记录下这个过程中的最短子串，直到r到字符串末尾</p><p>是否满足条件，我使用的是对象中属性的值是否均为0，<code>obj.every(item=&gt;item===0)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minWindow = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==t)&#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.length&lt;t.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>,r=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> obj=&#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="string">&quot;&quot;</span>,len=s.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;t.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj[t[i]])&#123;</span><br><span class="line">            obj[t[i]]++</span><br><span class="line">        &#125;<span class="keyword">else</span> obj[t[i]]=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(r&lt;s.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[r] <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            obj[s[r]]--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> t=<span class="built_in">Object</span>.values(obj).some(<span class="function"><span class="params">item</span>=&gt;</span>item&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span>(!t &amp;&amp; l&lt;s.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;=len)&#123;</span><br><span class="line">                len=r-l+<span class="number">1</span></span><br><span class="line">                res=s.slice(l,r+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[l] <span class="keyword">in</span> obj)&#123;</span><br><span class="line">                obj[s[l]]++</span><br><span class="line">            &#125;</span><br><span class="line">            l++</span><br><span class="line">            t=<span class="built_in">Object</span>.values(obj).some(<span class="function"><span class="params">item</span>=&gt;</span>item&gt;<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        r++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><p>需要找到环形链表的开头位置</p><p>我们能够根据快慢指针是否相遇来判断链表是否有环，那如何查找链表环开始的位置呢？</p><p>答案就藏在<strong>快慢指针相遇的那个位置</strong></p><p><a target="_blank" rel="noopener" href="https://picgoxl.oss-cn-beijing.aliyuncs.com/img/image-20220329194934807.png">https://picgoxl.oss-cn-beijing.aliyuncs.com/img/image-20220329194934807.png</a></p><p>上图中，表示的是快慢指针的相遇，当他们相遇时，快指针走的距离是慢指针的二倍，所以橙色线长度==红色线长度（慢指针移动距离），他们存在重叠部分，将<strong>重叠部分</strong>消去后，就是上面红色框的长度等于下面红色框的长度，意思就是a从快慢指针<strong>相遇的位置</strong>开始移动，同时b从<strong>头结点</strong>开始移动，当他们<strong>相遇</strong>时，移动了相同的距离，而他们就位于<strong>环形链表开始的位置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l=head,r=head</span><br><span class="line">    <span class="keyword">while</span>(r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r.next)&#123;</span><br><span class="line">            r=r.next.next</span><br><span class="line">            l=l.next</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            r=head</span><br><span class="line">            <span class="keyword">while</span>(l!==r)&#123;</span><br><span class="line">                l=l.next</span><br><span class="line">                r=r.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="680-验证回文字符串"><a href="#680-验证回文字符串" class="headerlink" title="680. 验证回文字符串"></a>680. 验证回文字符串</h2><div class="note default modern"><p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p><p>输入: s = “abca”输出: true解释: 你可以删除c字符。</p></div><p>可以使用递归一次的方法，<strong>尝试性删除</strong>掉某个导致不能构成回文的字符，然后判断其结果</p><p>要将判断回文和操作<strong>解耦</strong>，不要写在一起，既判断又操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> validPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tem = foo(s)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> tem==<span class="string">&#x27;boolean&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> [l,r]=tem</span><br><span class="line">  <span class="keyword">let</span> t = foo(s.slice(l + <span class="number">1</span>, r + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">if</span>(t===<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> m = foo(s.slice(l, r))</span><br><span class="line">  <span class="keyword">return</span> m===<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">      r = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">        l++, r--</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">return</span> [l, r]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a>524. 通过删除字母匹配到字典里最长单词</h2><div class="note default modern"><p>给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。<br>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p><p>输入：s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]输出：”apple”</p></div><p>比较s和dictionary中每一个字符串，<strong>比较过程使用双指针</strong>，如果在s中能找到分隔字符组合起来的子串等于dictionary中的某字符串，就返回true，最后综合比较所有满足条件的，返回最长的字典序最小的（比较字典序，直接使用大于小于号）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">dictionary</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findLongestWord = <span class="function"><span class="keyword">function</span>(<span class="params">s, dictionary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        obj[s[i]]=(obj[s[i]]||<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;dictionary.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c=dictionary[i]</span><br><span class="line">        <span class="keyword">if</span>(fun(s,c))&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.length&gt;res.length)&#123;</span><br><span class="line">                res=c</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c.length===res.length &amp;&amp; c&lt;res)&#123;</span><br><span class="line">                res=c</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">str1,str2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> l=<span class="number">0</span>,r=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;str1.length &amp;&amp; r&lt;str2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[l]===str2[r])&#123;</span><br><span class="line">                l++,r++</span><br><span class="line">            &#125;<span class="keyword">else</span> l++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (r===str2.length)?<span class="literal">true</span>:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nim-game/">292. Nim 游戏</a></h2><p>脑筋急转弯了属于是</p><p>多想，要去主动找规律，不是盲目做题（看答案之前我就是盲目做题….）</p><p><code>return n%(min+max)!==0</code></p><p><br></p><h2 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="**338. 比特位计数"></a>**338. 比特位计数</h2><ol><li>Brian Kernighan 算法<div class="note primary flat"><p>原理是：对于任意整数 x，令 x=x &amp; (x−1)，该运算将 x 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」。</p></div>很迷的一点是，下面这两段表示的是一个意思，但是下面那个就会超时<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        arr[i]=fun(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">x</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        x &amp;= (x-<span class="number">1</span>)</span><br><span class="line">        num++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>超时：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> num=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            i &amp;= (i-<span class="number">1</span>)</span><br><span class="line">            num++</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i]=num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>动态规划 最高有效位<div class="note primary flat"><p>原理是：对于任意整数 x，令 x=x &amp; (x−1)，该运算将 x 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」。<br>选择好高位high，令 <strong>arr[i]=arr[i-high]+1</strong></p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> high=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i&amp;(i-<span class="number">1</span>))==<span class="number">0</span>)&#123;</span><br><span class="line">            high=i</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i]=arr[i-high]+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>动态规划 最低有效位<div class="note primary flat"><p><strong>bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)</strong></p></div></li><li>动态规划 最低设置位<div class="note primary flat"><p><strong>bits[i]=bits[i&amp;(i-1)]+1</strong></p></div></li></ol><div class="note warning modern"><p><strong>总的来说</strong>，两个方向：</p><ul><li>使用x=x&amp;(x-1)，挨个计算每个数，直到x为0</li><li>动态规划<ul><li>bits[i]=bits[i-highbit]+1</li><li>bits[i]=bits[i&gt;&gt;1]+(i&amp;1)</li><li>bits[i]=bits[i&amp;(i-1)]+1</li></ul></li></ul></div><p><br></p><h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2><p>觉得自己确实有长进了，能独立把这类型题解出来了</p><p>刚开始的代码一气呵成，但一直结果不正确，最后发现，是跟1有关的问题。</p><p>因为在这道题中，是想寻找周围全是0的1构成的个数，需要<strong>深度搜索</strong>，所以<strong>在访问到某个1后就必须将其修改掉</strong>，防止循环访问，我们将其变为-1。那么当前访问的1<strong>最终返回true</strong>即确实被0包围的<strong>条件</strong>是：深度搜索周围的数返回的结果全为true。</p><p>那么我们思考下，什么时候会返回true：假设数A为我们当前访问的数，假设四个方向被0包围的个数<strong>num</strong>初始化为0，那么A周围如果出现<strong>访问不合法或者数字为0</strong> 的情况，num就会+1；<strong>否则</strong>就继续访问，获得该访问返回的结果，如果是true的话num就+1，最终如果num为4的话，说明A周围四个方向全部都被0包围了，返回true。</p><p>但，是否漏掉了什么？ 对，<strong>最后一个访问点，也需要周围全是0吗？</strong>（此处包括访问不合法情况） 那么它<strong>周围的1怎么考虑呢？</strong> 这也是我在最后发现并修改后把题AC的关键点。此时该数周围的1已经全都变成了-1，它返回true的可能是什么？是<strong>周围除了0就是-1</strong>，所以在num++的判断条件需添加一条-1，即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!valid(temx,temy) || grid[temx][temy]===<span class="string">&quot;0&quot;</span> || grid[temx][temy] === <span class="string">&quot;-1&quot;</span>) num++</span><br></pre></td></tr></table></figure><p>完整：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numIslands = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 寻找周围全是0的1</span></span><br><span class="line">  <span class="keyword">let</span> len1=grid.length,len2=grid[<span class="number">0</span>].length,res=<span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> xx=[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],yy=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len2;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid[i][j]===<span class="string">&quot;1&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> t=fun(i,j)</span><br><span class="line">        <span class="keyword">if</span>(t) res++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid[x][y]===<span class="string">&quot;0&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">0</span></span><br><span class="line">    grid[x][y]=<span class="string">&quot;-1&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> temx=x+xx[i],temy=y+yy[i]</span><br><span class="line">      <span class="keyword">if</span>(!valid(temx,temy) || grid[temx][temy]===<span class="string">&quot;0&quot;</span> || grid[temx][temy] === <span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        num++</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[temx][temy]===<span class="string">&quot;1&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> t=fun(temx,temy)</span><br><span class="line">        <span class="keyword">if</span>(t) num++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num===<span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">valid</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (x&gt;=<span class="number">0</span> &amp;&amp; x&lt;len1 &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;len2)?<span class="literal">true</span>:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br><p></p><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><p>没想到一次就AC了</p><p>需要多加注意的就是<strong>在dfs的过程中传递的num参数</strong>，当当前岛屿为0时就返回0，否则设置num为1，然后在该岛屿四周继续搜索，在num的基础上加dfs四周元素的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len1=grid.length,len2=grid[<span class="number">0</span>].length</span><br><span class="line">  <span class="keyword">let</span> res=<span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> xx=[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],yy=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len2;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid[i][j])&#123;</span><br><span class="line">        <span class="keyword">let</span> t=dfs(i,j,<span class="number">0</span>)</span><br><span class="line">        res=<span class="built_in">Math</span>.max(res,t)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">x,y,num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid[x][y]===<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    num=<span class="number">1</span></span><br><span class="line">    grid[x][y]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> temx=x+xx[i],temy=y+yy[i]</span><br><span class="line">      <span class="keyword">if</span>(valid(temx,temy))&#123;</span><br><span class="line">        num=num+dfs(temx,temy,<span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">valid</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;len1 &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;len2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">xinxin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://xinxin-l.github.io/2022/02/23/%E5%8A%9B%E6%89%A3100%E7%83%AD%E9%A2%98%E4%B9%8B%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">http://xinxin-l.github.io/2022/02/23/%E5%8A%9B%E6%89%A3100%E7%83%AD%E9%A2%98%E4%B9%8B%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xinxin-l.github.io" target="_blank">xinxin's little world</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/xinxin-l-assets/img/v2-11fed20c0b85026cff9036f599ca3d2f_b.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/10/%E7%BD%91%E7%AB%99/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/sheep.jpg" onerror='onerror=null,src="https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">推荐网站</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/21/%E6%B7%BB%E5%8A%A0%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/bear.jpg" onerror='onerror=null,src="https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">添加外挂标签</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">xinxin</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xinxin-l"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xinxin-l" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1581170174&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客呀，有问题可以在留言板留言，看到会第一时间回复~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-text">155. 最小栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">5. 最长回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#28-%E5%AE%9E%E7%8E%B0strStr"><span class="toc-text">28. 实现strStr()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text">49. 字母异位词分组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-text">128. 最长连续序列</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">26. 删除有序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-text">48. 旋转图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-text">56. 合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-text">75. 颜色分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">88. 合并两个有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">136. 只出现一次的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="toc-text">240. 搜索二维矩阵 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#769-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97"><span class="toc-text">769. 最多能完成排序的块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-text">141. 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">234. 回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">237. 删除链表中的节点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">94. 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">96. 不同的二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">98. 验证二叉搜索树*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">101. 对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">104. 二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">226. 反转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#545-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-text">545. 二叉树的直径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">235. 二叉搜索树的最近公共祖先**</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF"><span class="toc-text">递归 回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%93%E5%90%88"><span class="toc-text">17. 电话号码的字母结合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-text">22. 括号生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-text">31. 下一个排列**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">46. 全排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-text">78. 子集**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-text">79. 单词搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII"><span class="toc-text">337. 打家劫舍III**</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">55. 跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-1"><span class="toc-text">56. 合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-text">135. 分发糖果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-text">406. 根据身高重建队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-text">455. 分发饼干</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">52. 不同路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">53. 最大子数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">64. 最小路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">70. 爬楼梯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-text">215. 数组中的第K个最大元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-text">347. 前 K 个高频元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-text">75. 最小覆盖子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="toc-text">142. 环形链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">680. 验证回文字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#524-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D"><span class="toc-text">524. 通过删除字母匹配到字典里最长单词</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#292-Nim-%E6%B8%B8%E6%88%8F"><span class="toc-text">292. Nim 游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0"><span class="toc-text">**338. 比特位计数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-text">200. 岛屿数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="toc-text">695. 岛屿的最大面积</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/18/%E6%9C%89%E5%85%B3ubuntu12-04%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="有关ubuntu12.04遇到的问题解决"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinxin-l/blog_img/main/img/green.jpg" onerror='this.onerror=null,this.src="https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png"' alt="有关ubuntu12.04遇到的问题解决"></a><div class="content"><a class="title" href="/2022/04/18/%E6%9C%89%E5%85%B3ubuntu12-04%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="有关ubuntu12.04遇到的问题解决">有关ubuntu12.04遇到的问题解决</a><time datetime="2022-04-18T13:55:53.000Z" title="发表于 2022-04-18 21:55:53">2022-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/10/%E7%BD%91%E7%AB%99/" title="推荐网站"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/sheep.jpg" onerror='this.onerror=null,this.src="https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png"' alt="推荐网站"></a><div class="content"><a class="title" href="/2022/03/10/%E7%BD%91%E7%AB%99/" title="推荐网站">推荐网站</a><time datetime="2022-03-10T02:29:24.000Z" title="发表于 2022-03-10 10:29:24">2022-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/23/%E5%8A%9B%E6%89%A3100%E7%83%AD%E9%A2%98%E4%B9%8B%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" title="LeetCode HOT 100 之总结记录"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/v2-11fed20c0b85026cff9036f599ca3d2f_b.jpg" onerror='this.onerror=null,this.src="https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png"' alt="LeetCode HOT 100 之总结记录"></a><div class="content"><a class="title" href="/2022/02/23/%E5%8A%9B%E6%89%A3100%E7%83%AD%E9%A2%98%E4%B9%8B%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" title="LeetCode HOT 100 之总结记录">LeetCode HOT 100 之总结记录</a><time datetime="2022-02-23T14:01:32.000Z" title="发表于 2022-02-23 22:01:32">2022-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/21/%E6%B7%BB%E5%8A%A0%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE/" title="添加外挂标签"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/bear.jpg" onerror='this.onerror=null,this.src="https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png"' alt="添加外挂标签"></a><div class="content"><a class="title" href="/2022/02/21/%E6%B7%BB%E5%8A%A0%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE/" title="添加外挂标签">添加外挂标签</a><time datetime="2022-02-21T06:58:48.000Z" title="发表于 2022-02-21 14:58:48">2022-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/15/%E3%80%90javaScript%E6%A1%88%E4%BE%8B%E3%80%91%E4%B9%8B%E7%B1%BB%E4%BC%BC%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%9A%84%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/" title="【javaScript案例】之类似购物车的效果实现"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/v2-604c6dc756119b14a4b407f07c90402a_1440w.jpg" onerror='this.onerror=null,this.src="https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png"' alt="【javaScript案例】之类似购物车的效果实现"></a><div class="content"><a class="title" href="/2022/02/15/%E3%80%90javaScript%E6%A1%88%E4%BE%8B%E3%80%91%E4%B9%8B%E7%B1%BB%E4%BC%BC%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%9A%84%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/" title="【javaScript案例】之类似购物车的效果实现">【javaScript案例】之类似购物车的效果实现</a><time datetime="2022-02-15T14:00:10.000Z" title="发表于 2022-02-15 22:00:10">2022-02-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://npm.elemecdn.com/xinxin-l-assets/img/v2-11fed20c0b85026cff9036f599ca3d2f_b.jpg)"><div id="footer-wrap"><div class="copyright"><span>&copy;2022</span><svg style="width:1.5em;height:1.5em" aria-hidden="true"><use xlink:href="#icon-Butterfly"></use></svg><span>xinxin</span></div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-brightgreen?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-coral?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p>Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"YPimyj5mUYmypjmkipCFGICC-gzGzoHsz",appKey:"WAmJjm9X7dxdNRukVNOSud1T",avatar:"wavatar",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!0},null))}"function"==typeof Valine?n():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(n)}{function loadOtherComment(){loadValine()}setTimeout(loadValine,0)}</script></div><script async src="//at.alicdn.com/t/font_3174164_6vqrxu2hu6r.js"></script><script async src="//at.alicdn.com/t/font_2032782_8ns648avijk.js"></script><div class="aplayer no-destroy" data-id="8356365697" data-server="tencent" data-type="playlist" data-fixed="true" data-autoplay="true"></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer color="169, 175, 182" opacity="0.7" zindex="-1" count="110" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script>window.$crisp=[],window.CRISP_WEBSITE_ID="1a9ead06-1d65-4ddd-80bc-568e69173527",d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s),$crisp.push(["safe",!0]),$crisp.push(["do","chat:hide"]),$crisp.push(["on","chat:closed",function(){$crisp.push(["do","chat:hide"])}]);var chatBtnHide,chatBtnShow,chatBtnFn=()=>{document.getElementById("chat_btn").addEventListener("click",(function(){$crisp.push(["do","chat:show"]),$crisp.push(["do","chat:open"])}))};chatBtnFn()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/03/10/网站/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/sheep.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-03-10</span><a class="blog-slider__title" href="2022/03/10/网站/" alt="">推荐网站</a><div class="blog-slider__text">学习前端推荐网站</div><a class="blog-slider__button" href="2022/03/10/网站/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/02/21/添加外挂标签/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/bear.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-02-21</span><a class="blog-slider__title" href="2022/02/21/添加外挂标签/" alt="">添加外挂标签</a><div class="blog-slider__text">引入外挂标签</div><a class="blog-slider__button" href="2022/02/21/添加外挂标签/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/02/15/javascript之set的用法/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/wow.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-02-15</span><a class="blog-slider__title" href="2022/02/15/javascript之set的用法/" alt="">javascript之set和weakset的用法</a><div class="blog-slider__text">简单介绍一下javascript中set和weakset集合的使用场景</div><a class="blog-slider__button" href="2022/02/15/javascript之set的用法/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/02/14/如何判断一个整数是不是2的幂次方？/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/eat.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-02-14</span><a class="blog-slider__title" href="2022/02/14/如何判断一个整数是不是2的幂次方？/" alt="">如何判断一个整数是不是2的幂次方？</a><div class="blog-slider__text">判断一个整数是不是2的幂次方的方法</div><a class="blog-slider__button" href="2022/02/14/如何判断一个整数是不是2的幂次方？/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/02/15/搞明白prototype和-proto/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/friend.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-02-15</span><a class="blog-slider__title" href="2022/02/15/搞明白prototype和-proto/" alt="">搞明白prototype和__proto__</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2022/02/15/搞明白prototype和-proto/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/02/15/为什么要清除浮动及如何清除浮动/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picgoxl.oss-cn-beijing.aliyuncs.com/img/v2-c7e4634445db435dd7c332bd80206f6c_1440w.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-02-15</span><a class="blog-slider__title" href="2022/02/15/为什么要清除浮动及如何清除浮动/" alt="">为什么要清除浮动及如何清除浮动</a><div class="blog-slider__text">关于CSS中什么是浮动、为什么要清除浮动以及如何清除浮动进行了简单的讲解</div><a class="blog-slider__button" href="2022/02/15/为什么要清除浮动及如何清除浮动/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/02/15/class的继承之super的使用/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xinxin-l-assets/img/green.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-02-15</span><a class="blog-slider__title" href="2022/02/15/class的继承之super的使用/" alt="">class的继承之super的使用</a><div class="blog-slider__text">javascript中class的继承一直是比较难懂的点，这篇文章就先来讲述一下class继承中super的用法</div><a class="blog-slider__button" href="2022/02/15/class的继承之super的使用/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/02/08/知识点总结/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picgoxl.oss-cn-beijing.aliyuncs.com/img/v2-35fe7108854ed56063e0ae1884616d46_1440w.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-02-08</span><a class="blog-slider__title" href="2022/02/08/知识点总结/" alt="">知识点总结</a><div class="blog-slider__text">包括CSS JS 浏览器原理等一些知识点的总结</div><a class="blog-slider__button" href="2022/02/08/知识点总结/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>function gitcalendar_injector_config(){document.getElementById("recent-posts").insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>'),console.log("已挂载gitcalendar")}document.getElementById("recent-posts")&&"/"===location.pathname&&(gitcalendar_injector_config(),GitCalendarInit("https://git-calendar-three.vercel.app/api?xinxin-l",["#e4dfd7","#f9f4dc","#f7e8aa","#f7e8aa","#f8df72","#fcd217","#fcc515","#f28e16","#fb8b05","#d85916","#f43e06"],"xinxin-l"))</script></body></html>